# Twenty CRM 代碼追蹤分析報告

> 生成時間：2025-10-14  
> 目的：系統性分析登入後遮罩問題的根本原因

---

## 📋 目錄

1. [前端啟動流程](#前端啟動流程)
2. [認證與登入流程](#認證與登入流程)
3. [用戶載入流程](#用戶載入流程)
4. [路由與導航機制](#路由與導航機制)
5. [UI 遮罩顯示邏輯](#ui-遮罩顯示邏輯)
6. [後端認證與 Token 處理](#後端認證與-token-處理)
7. [關鍵問題點分析](#關鍵問題點分析)
8. [建議修復方案](#建議修復方案)

---

## 1. 前端啟動流程

### 1.1 入口點鏈路

```
index.html (line 87)
  ↓ <script type="module" src="/src/index.tsx"></script>
  ↓
index.tsx (line 14)
  ↓ root.render(<App />)
  ↓
App.tsx (line 18-47)
  ↓ <RecoilRoot> → <AppErrorBoundary> → <I18nProvider> → <AppRouter>
  ↓
AppRouter.tsx (line 16-21)
  ↓ <RouterProvider router={useCreateAppRouter(...)} />
  ↓
useCreateAppRouter.tsx (line 31-82)
  ↓ createBrowserRouter with routes
```

### 1.2 關鍵 Route 配置

```typescript
// useCreateAppRouter.tsx: line 37-80
<Route element={<AppRouterProviders />}>
  <Route element={<DefaultLayout />}>
    <Route path={AppPath.Verify} element={<VerifyLoginTokenEffect />} />
    <Route path={AppPath.SignInUp} element={<SignInUp />} />
    // ... 其他路由
  </Route>
</Route>
```

**重點**：`AppPath.Verify` 路由使用 `DefaultLayout`，會根據 `useShowAuthModal` 決定是否顯示遮罩。

---

## 2. 認證與登入流程

### 2.1 VerifyLoginTokenEffect 組件

**文件**：`packages/twenty-front/src/modules/auth/components/VerifyLoginTokenEffect.tsx`

```typescript
// line 24-34
useEffect(() => {
  if (!clientConfigLoaded) return;

  if (isDefined(loginToken)) {
    verifyLoginToken(loginToken);  // 呼叫驗證
  } else if (!isLogged) {
    navigate(AppPath.SignInUp);
  }
}, [clientConfigLoaded]);
```

**流程**：
1. 等待 `clientConfigLoaded` 為 true
2. 如果 URL 有 `loginToken`，呼叫 `verifyLoginToken(loginToken)`
3. `verifyLoginToken` 內部呼叫 `getAuthTokensFromLoginToken(loginToken)`

### 2.2 useAuth Hook - getAuthTokensFromLoginToken

**文件**：`packages/twenty-front/src/modules/auth/hooks/useAuth.ts`

```typescript
// line 329-380
const handleGetAuthTokensFromLoginToken = useCallback(
  async (loginToken: string) => {
    try {
      const getAuthTokensResult = await getAuthTokensFromLoginToken({
        variables: { loginToken: loginToken, origin },
      });

      if (!getAuthTokensResult.data?.getAuthTokensFromLoginToken) {
        throw new Error('No getAuthTokensFromLoginToken result');
      }

      // 關鍵：呼叫 handleLoadWorkspaceAfterAuthentication
      await handleLoadWorkspaceAfterAuthentication(
        getAuthTokensResult.data.getAuthTokensFromLoginToken.tokens,
      );
    } catch (error) {
      // 處理 2FA 錯誤...
    }
  },
  [/* deps */],
);
```

### 2.3 handleLoadWorkspaceAfterAuthentication

**文件**：`packages/twenty-front/src/modules/auth/hooks/useAuth.ts`

```typescript
// line 316-327
const handleLoadWorkspaceAfterAuthentication = useCallback(
  async (authTokens: AuthTokenPair) => {
    handleSetAuthTokens(authTokens);  // 設置 token

    // TODO: 這裡有註釋說不能並行執行
    await loadCurrentUser();           // 載入用戶
    await refreshObjectMetadataItems(); // 刷新 metadata
  },
  [loadCurrentUser, handleSetAuthTokens, refreshObjectMetadataItems],
);
```

**關鍵問題**：`loadCurrentUser()` 完成後，**沒有設置 `isCurrentUserLoadedState` 為 true**！

---

## 3. 用戶載入流程

### 3.1 useLoadCurrentUser Hook

**文件**：`packages/twenty-front/src/modules/users/hooks/useLoadCurrentUser.ts`

```typescript
// line 45-135
const loadCurrentUser = useCallback(async () => {
  const currentUserResult = await getCurrentUser({
    fetchPolicy: 'network-only',
  });

  const coreViewsResult = await findAllCoreViews({
    fetchPolicy: 'network-only',
  });

  // ... 設置各種 state
  setCurrentUser(user);
  setCurrentWorkspace(workspace);
  setCurrentWorkspaceMember(workspaceMember);
  // ... 等等

  // ❌ 問題：這裡沒有 setIsCurrentUserLoaded(true)

  return { user, workspaceMember, workspace };
}, [/* deps */]);
```

**對比：UserAndViewsProviderEffect**

**文件**：`packages/twenty-front/src/modules/users/components/UserAndViewsProviderEffect.tsx`

```typescript
// line 207-211
useEffect(() => {
  if (localIsCurrentUserLoaded && localAreViewsLoaded) {
    setIsCurrentUserLoaded(true);  // ✅ 這裡有設置！
  }
}, [localIsCurrentUserLoaded, localAreViewsLoaded, setIsCurrentUserLoaded]);
```

**結論**：
- `UserAndViewsProviderEffect` 使用 `useGetCurrentUserQuery` (自動執行)
- `useLoadCurrentUser` 使用 `useGetCurrentUserLazyQuery` (手動執行)
- **`useLoadCurrentUser` 沒有設置 `isCurrentUserLoadedState`**，導致後續邏輯無法觸發！

---

## 4. 路由與導航機制

### 4.1 PageChangeEffect

**文件**：`packages/twenty-front/src/modules/app/effect-components/PageChangeEffect.tsx`

```typescript
// line 110-116
useEffect(() => {
  initializeQueryParamState();

  if (isDefined(pageChangeEffectNavigateLocation)) {
    navigate(pageChangeEffectNavigateLocation);  // 執行導航
  }
}, [navigate, pageChangeEffectNavigateLocation, initializeQueryParamState]);
```

### 4.2 usePageChangeEffectNavigateLocation

**文件**：`packages/twenty-front/src/hooks/usePageChangeEffectNavigateLocation.ts`

```typescript
// line 17-155
export const usePageChangeEffectNavigateLocation = () => {
  const isLoggedIn = useIsLogged();
  const { isOnAWorkspace } = useIsCurrentLocationOnAWorkspace();
  const onboardingStatus = useOnboardingStatus();

  // line 30-35: 定義 onGoingUserCreationPaths
  const onGoingUserCreationPaths = [
    AppPath.Invite,
    AppPath.SignInUp,
    AppPath.VerifyEmail,
    AppPath.Verify,  // ← /verify 在這裡
  ];

  // line 134-141: 關鍵邏輯
  if (
    onboardingStatus === OnboardingStatus.COMPLETED &&
    someMatchingLocationOf([...onboardingPaths, ...onGoingUserCreationPaths]) &&
    !isMatchingLocation(location, AppPath.ResetPassword) &&
    isLoggedIn
  ) {
    return defaultHomePagePath;  // 應該導航到首頁
  }

  return;  // 不導航
};
```

**觸發條件**：
1. `onboardingStatus === OnboardingStatus.COMPLETED` ✅
2. 當前在 `onGoingUserCreationPaths` (包括 `/verify`) ✅
3. `isLoggedIn` 為 true ✅

**問題**：這個邏輯依賴於 `onboardingStatus`，而 `onboardingStatus` 來自 `currentUserState`。

### 4.3 useOnboardingStatus

**文件**：`packages/twenty-front/src/modules/onboarding/hooks/useOnboardingStatus.ts`

```typescript
// line 7-11
export const useOnboardingStatus = (): OnboardingStatus | null | undefined => {
  const currentUser = useRecoilValue(currentUserState);
  const isLoggedIn = useIsLogged();
  return isLoggedIn ? currentUser?.onboardingStatus : undefined;
};
```

**關鍵**：`currentUser` 必須已經載入，才能取得 `onboardingStatus`。

---

## 5. UI 遮罩顯示邏輯

### 5.1 DefaultLayout

**文件**：`packages/twenty-front/src/modules/ui/layout/page/components/DefaultLayout.tsx`

```typescript
// line 64: 取得 showAuthModal
const showAuthModal = useShowAuthModal();

// line 99-116: 根據 showAuthModal 決定渲染內容
{showAuthModal ? (
  <>
    <StyledMainContainer>
      <SignInBackgroundMockPage />
    </StyledMainContainer>
    <AnimatePresence mode="wait">
      <LayoutGroup>
        <AuthModal>
          <Outlet />  {/* VerifyLoginTokenEffect 在這裡 */}
        </AuthModal>
      </LayoutGroup>
    </AnimatePresence>
  </>
) : (
  <StyledMainContainer>
    <AppErrorBoundary FallbackComponent={AppPageErrorFallback}>
      <Outlet />
    </AppErrorBoundary>
  </StyledMainContainer>
)}
```

### 5.2 useShowAuthModal

**文件**：`packages/twenty-front/src/modules/ui/layout/hooks/useShowAuthModal.ts`

```typescript
// line 10-30
return useMemo(() => {
  if (
    isMatchingLocation(location, AppPath.Invite) ||
    isMatchingLocation(location, AppPath.InviteTeam) ||
    isMatchingLocation(location, AppPath.CreateProfile) ||
    isMatchingLocation(location, AppPath.SyncEmails) ||
    isMatchingLocation(location, AppPath.ResetPassword) ||
    isMatchingLocation(location, AppPath.VerifyEmail) ||
    isMatchingLocation(location, AppPath.Verify) ||  // ← 這裡！
    isMatchingLocation(location, AppPath.SignInUp) ||
    isMatchingLocation(location, AppPath.CreateWorkspace) ||
    isMatchingLocation(location, AppPath.PlanRequired) ||
    isMatchingLocation(location, AppPath.PlanRequiredSuccess) ||
    isMatchingLocation(location, AppPath.BookCallDecision) ||
    isMatchingLocation(location, AppPath.BookCall)
  ) {
    return true;  // 顯示遮罩
  }

  return false;
}, [location]);
```

**結論**：只要在 `/verify` 路徑，`showAuthModal` 就會是 `true`，遮罩就會顯示。

### 5.3 UserProvider

**文件**：`packages/twenty-front/src/modules/users/components/UserProvider.tsx`

```typescript
// line 12-34
export const UserProvider = ({ children }: React.PropsWithChildren) => {
  const isCurrentUserLoaded = useRecoilValue(isCurrentUserLoadedState);
  const location = useLocation();

  const { dateFormat, timeFormat, timeZone } = useDateTimeFormat();

  // line 18-22: 如果用戶未載入且不在特定路徑，顯示 Loader
  return !isCurrentUserLoaded &&
    !isMatchingLocation(location, AppPath.Verify) &&
    !isMatchingLocation(location, AppPath.VerifyEmail) &&
    !isMatchingLocation(location, AppPath.CreateWorkspace) ? (
    <UserOrMetadataLoader />
  ) : (
    <UserContext.Provider value={{ dateFormat, timeFormat, timeZone }}>
      {children}
    </UserContext.Provider>
  );
};
```

**重點**：`/verify` 路徑被排除在 Loader 檢查之外，所以即使 `isCurrentUserLoaded` 為 false，也不會顯示 Loader。

---

## 6. 後端認證與 Token 處理

### 6.1 AuthResolver - getAuthTokensFromLoginToken

**文件**：`packages/twenty-server/src/engine/core-modules/auth/auth.resolver.ts`

```typescript
// line 549-600
@Mutation(() => AuthTokens)
@UseGuards(PublicEndpointGuard)
async getAuthTokensFromLoginToken(
  @Args() getAuthTokensFromLoginTokenInput: GetAuthTokensFromLoginTokenInput,
  @Args('origin') origin: string,
): Promise<AuthTokens> {
  const tokenPayload = await this.validateAndDecodeLoginToken(
    getAuthTokensFromLoginTokenInput.loginToken,
  );

  const workspace = await this.validateWorkspaceAccess(
    origin,
    tokenPayload.workspaceId,
  );

  const { user, userWorkspace } = await this.validateUserAccess(
    tokenPayload.sub,
    tokenPayload.workspaceId,
  );

  // ... 驗證邏輯

  return await this.authService.verify(
    user.email,
    workspace.id,
    tokenPayload.authProvider,
  );
}
```

**流程**：
1. 驗證 loginToken
2. 驗證 workspace 存取權限
3. 驗證 user 存取權限
4. 返回 `AuthTokens` (accessToken + refreshToken)

### 6.2 後端配置

**啟動腳本**：`start_all_service_start.sh`

```bash
# line 126-156: 關鍵環境變數
export SERVER_URL=${BACKEND_URL}
export FRONTEND_URL=${FRONTEND_URL}
export IS_MULTIWORKSPACE_ENABLED=${IS_MULTIWORKSPACE_ENABLED}
export DEFAULT_SUBDOMAIN=${DEFAULT_SUBDOMAIN}
```

**配置文件**：`twenty-config.sh`

```bash
# line 14: 外部主機
export EXTERNAL_HOST="118.168.188.27.nip.io"

# line 20-21: 端口
export FRONTEND_PORT=8866
export BACKEND_PORT=8867

# line 54: 默認子域名
export DEFAULT_SUBDOMAIN="app"
```

---

## 7. 關鍵問題點分析

### 🔴 問題 1：isCurrentUserLoadedState 未被設置

**位置**：`useLoadCurrentUser.ts` (line 45-135)

**現象**：
- `loadCurrentUser()` 函數成功執行
- 所有 state 都正確設置 (currentUser, workspace, etc.)
- **但 `isCurrentUserLoadedState` 沒有被設置為 true**

**影響**：
- `UserAndViewsProviderEffect` 的 `shouldSkip` 條件 (line 91-95) 依賴 `isCurrentUserLoaded`
- 如果 `isCurrentUserLoaded` 為 false，`UserAndViewsProviderEffect` 會嘗試重新載入用戶
- 但因為 `useAuth` 的 `loadCurrentUser` 已經執行過，可能導致狀態不一致

### 🔴 問題 2：導航邏輯未觸發

**位置**：`usePageChangeEffectNavigateLocation.ts` (line 134-141)

**條件鏈**：
```
onboardingStatus === COMPLETED
  ↓ 依賴
currentUser?.onboardingStatus
  ↓ 依賴
currentUserState (Recoil)
  ↓ 設置於
loadCurrentUser() 或 UserAndViewsProviderEffect
```

**問題**：
- 如果 `loadCurrentUser()` 沒有設置 `isCurrentUserLoadedState`
- `UserAndViewsProviderEffect` 可能會重新執行
- 但 `shouldSkip` 條件會阻止它在 `/verify` 路徑執行 (line 94)
- 導致 `currentUser` 可能未正確載入，`onboardingStatus` 為 undefined
- 導航邏輯不會觸發

### 🔴 問題 3：雙重用戶載入機制

**兩個載入路徑**：

1. **useAuth → loadCurrentUser (手動)**
   - 使用 `useGetCurrentUserLazyQuery`
   - 在 `handleLoadWorkspaceAfterAuthentication` 中呼叫
   - **不設置 `isCurrentUserLoadedState`**

2. **UserAndViewsProviderEffect (自動)**
   - 使用 `useGetCurrentUserQuery`
   - 在 `AppRouterProviders` 中自動執行
   - **設置 `isCurrentUserLoadedState`**
   - 但有 `shouldSkip` 條件會在 `/verify` 路徑跳過

**衝突**：
- 在 `/verify` 路徑，`UserAndViewsProviderEffect` 被跳過
- `useAuth` 的 `loadCurrentUser` 執行，但不設置 `isCurrentUserLoadedState`
- 導致系統認為用戶未載入，但實際上已經載入

### 🔴 問題 4：遮罩顯示邏輯

**位置**：`useShowAuthModal.ts` (line 18)

```typescript
isMatchingLocation(location, AppPath.Verify) ||  // 只要在 /verify 就顯示
```

**問題**：
- 遮罩顯示完全基於路徑
- 不考慮認證狀態或用戶載入狀態
- 只要在 `/verify`，遮罩就會顯示
- **必須導航離開 `/verify` 才能隱藏遮罩**

---

## 8. 建議修復方案

### ✅ 方案 1：在 useLoadCurrentUser 中設置 isCurrentUserLoadedState

**文件**：`packages/twenty-front/src/modules/users/hooks/useLoadCurrentUser.ts`

**修改**：

```typescript
import { isCurrentUserLoadedState } from '@/auth/states/isCurrentUserLoadedState';
import { useSetRecoilState } from 'recoil';

export const useLoadCurrentUser = () => {
  // ... 其他 setters
  const setIsCurrentUserLoaded = useSetRecoilState(isCurrentUserLoadedState);

  const loadCurrentUser = useCallback(async () => {
    // ... 現有邏輯

    if (isDefined(coreViewsResult.data?.getCoreViews)) {
      setCoreViews(coreViewsResult.data.getCoreViews);
    }

    // ✅ 新增：設置用戶已載入
    setIsCurrentUserLoaded(true);

    return { user, workspaceMember, workspace };
  }, [
    // ... 現有 deps
    setIsCurrentUserLoaded,  // ✅ 新增到依賴
  ]);

  return { loadCurrentUser };
};
```

**優點**：
- 最小改動
- 確保 `isCurrentUserLoadedState` 正確設置
- 觸發後續導航邏輯

**缺點**：
- 可能與 `UserAndViewsProviderEffect` 產生競爭條件
- 需要確保兩個載入路徑不會衝突

### ✅ 方案 2：修改 UserAndViewsProviderEffect 的 shouldSkip 條件

**文件**：`packages/twenty-front/src/modules/users/components/UserAndViewsProviderEffect.tsx`

**修改**：

```typescript
// line 91-95
const shouldSkip =
  !isLoggedIn ||
  isCurrentUserLoaded ||
  // ❌ 移除這兩行
  // isMatchingLocation(location, AppPath.Verify) ||
  // isMatchingLocation(location, AppPath.VerifyEmail);
```

**優點**：
- 確保用戶數據在所有路徑都會載入
- 統一用戶載入邏輯

**缺點**：
- 可能導致重複載入
- 需要測試對其他流程的影響

### ✅ 方案 3：修改 VerifyLoginTokenEffect 在成功後立即導航

**文件**：`packages/twenty-front/src/modules/auth/components/VerifyLoginTokenEffect.tsx`

**修改**：

```typescript
export const VerifyLoginTokenEffect = () => {
  const [searchParams] = useSearchParams();
  const loginToken = searchParams.get('loginToken');

  const isLogged = useIsLogged();
  const navigate = useNavigateApp();
  const { verifyLoginToken } = useVerifyLogin();
  const { defaultHomePagePath } = useDefaultHomePagePath();  // ✅ 新增

  const { isSaved: clientConfigLoaded } = useRecoilValue(
    clientConfigApiStatusState,
  );

  useEffect(() => {
    if (!clientConfigLoaded) return;

    if (isDefined(loginToken)) {
      verifyLoginToken(loginToken).then(() => {
        // ✅ 新增：驗證成功後立即導航
        navigate(defaultHomePagePath);
      });
    } else if (!isLogged) {
      navigate(AppPath.SignInUp);
    }
  }, [clientConfigLoaded, navigate, defaultHomePagePath]);  // ✅ 更新 deps

  return <></>;
};
```

**優點**：
- 直接解決停留在 `/verify` 的問題
- 不依賴 `PageChangeEffect` 的複雜邏輯

**缺點**：
- 可能過早導航，用戶數據可能未完全載入
- 需要確保 `loadCurrentUser` 完成後再導航

### ✅ 方案 4：修改 useVerifyLogin 在成功後導航

**文件**：`packages/twenty-front/src/modules/auth/hooks/useVerifyLogin.ts`

**修改**：

```typescript
import { useDefaultHomePagePath } from '@/navigation/hooks/useDefaultHomePagePath';

export const useVerifyLogin = () => {
  const { enqueueErrorSnackBar } = useSnackBar();
  const navigate = useNavigateApp();
  const { getAuthTokensFromLoginToken } = useAuth();
  const { t } = useLingui();
  const { defaultHomePagePath } = useDefaultHomePagePath();  // ✅ 新增

  const verifyLoginToken = async (loginToken: string) => {
    try {
      await getAuthTokensFromLoginToken(loginToken);
      // ✅ 新增：成功後導航
      navigate(defaultHomePagePath);
    } catch {
      enqueueErrorSnackBar({
        message: t`Authentication failed`,
      });
      navigate(AppPath.SignInUp);
    }
  };

  return { verifyLoginToken };
};
```

**優點**：
- 集中處理驗證後的導航
- 確保 token 設置完成後再導航

**缺點**：
- 仍然可能在用戶數據完全載入前導航
- 需要等待 `loadCurrentUser` 完成

### ✅ 方案 5：組合方案 (推薦)

**步驟 1**：在 `useLoadCurrentUser` 中設置 `isCurrentUserLoadedState`

**步驟 2**：在 `useAuth.handleLoadWorkspaceAfterAuthentication` 中等待載入完成

```typescript
const handleLoadWorkspaceAfterAuthentication = useCallback(
  async (authTokens: AuthTokenPair) => {
    handleSetAuthTokens(authTokens);

    await loadCurrentUser();
    await refreshObjectMetadataItems();

    // ✅ 新增：確保狀態已更新
    // 這裡可以添加一個小延遲，確保 Recoil state 已經傳播
  },
  [loadCurrentUser, handleSetAuthTokens, refreshObjectMetadataItems],
);
```

**步驟 3**：依賴 `PageChangeEffect` 自動導航

**優點**：
- 保持原有架構
- 確保狀態正確設置
- 利用現有的導航邏輯

**缺點**：
- 需要多處修改
- 需要仔細測試

---

## 9. 總結

### 根本原因

1. **`useLoadCurrentUser` 沒有設置 `isCurrentUserLoadedState`**
2. **`UserAndViewsProviderEffect` 在 `/verify` 路徑被跳過**
3. **導航邏輯依賴 `onboardingStatus`，但 `currentUser` 可能未正確載入**
4. **遮罩顯示純粹基於路徑，必須導航離開才能隱藏**

### 建議優先級

1. **高優先級**：方案 1 - 在 `useLoadCurrentUser` 中設置 `isCurrentUserLoadedState`
2. **中優先級**：方案 4 - 在 `useVerifyLogin` 中添加導航
3. **低優先級**：方案 2 - 修改 `UserAndViewsProviderEffect` 的 `shouldSkip`

### 測試檢查點

修復後需要驗證：

1. ✅ 登入後能正確導航到首頁
2. ✅ `isCurrentUserLoadedState` 正確設置為 true
3. ✅ `currentUser` 包含完整數據
4. ✅ `onboardingStatus` 正確
5. ✅ 遮罩正確隱藏
6. ✅ 不影響其他認證流程 (Google, Microsoft, etc.)
7. ✅ 不影響 onboarding 流程

---

## 10. 附錄：關鍵文件清單

### 前端核心文件

| 文件 | 路徑 | 關鍵函數/組件 |
|------|------|--------------|
| index.tsx | packages/twenty-front/src/index.tsx | root.render |
| App.tsx | packages/twenty-front/src/modules/app/components/App.tsx | App |
| AppRouter.tsx | packages/twenty-front/src/modules/app/components/AppRouter.tsx | AppRouter |
| useCreateAppRouter.tsx | packages/twenty-front/src/modules/app/hooks/useCreateAppRouter.tsx | useCreateAppRouter |
| AppRouterProviders.tsx | packages/twenty-front/src/modules/app/components/AppRouterProviders.tsx | AppRouterProviders |

### 認證相關

| 文件 | 路徑 | 關鍵函數/組件 |
|------|------|--------------|
| VerifyLoginTokenEffect.tsx | packages/twenty-front/src/modules/auth/components/VerifyLoginTokenEffect.tsx | VerifyLoginTokenEffect |
| useAuth.ts | packages/twenty-front/src/modules/auth/hooks/useAuth.ts | useAuth, handleGetAuthTokensFromLoginToken, handleLoadWorkspaceAfterAuthentication |
| useVerifyLogin.ts | packages/twenty-front/src/modules/auth/hooks/useVerifyLogin.ts | useVerifyLogin, verifyLoginToken |
| AuthProvider.tsx | packages/twenty-front/src/modules/auth/components/AuthProvider.tsx | AuthProvider |

### 用戶載入

| 文件 | 路徑 | 關鍵函數/組件 |
|------|------|--------------|
| useLoadCurrentUser.ts | packages/twenty-front/src/modules/users/hooks/useLoadCurrentUser.ts | useLoadCurrentUser, loadCurrentUser |
| UserProvider.tsx | packages/twenty-front/src/modules/users/components/UserProvider.tsx | UserProvider |
| UserAndViewsProviderEffect.tsx | packages/twenty-front/src/modules/users/components/UserAndViewsProviderEffect.tsx | UserAndViewsProviderEffect |

### 路由與導航

| 文件 | 路徑 | 關鍵函數/組件 |
|------|------|--------------|
| PageChangeEffect.tsx | packages/twenty-front/src/modules/app/effect-components/PageChangeEffect.tsx | PageChangeEffect |
| usePageChangeEffectNavigateLocation.ts | packages/twenty-front/src/hooks/usePageChangeEffectNavigateLocation.ts | usePageChangeEffectNavigateLocation |
| useOnboardingStatus.ts | packages/twenty-front/src/modules/onboarding/hooks/useOnboardingStatus.ts | useOnboardingStatus |

### UI Layout

| 文件 | 路徑 | 關鍵函數/組件 |
|------|------|--------------|
| DefaultLayout.tsx | packages/twenty-front/src/modules/ui/layout/page/components/DefaultLayout.tsx | DefaultLayout |
| useShowAuthModal.ts | packages/twenty-front/src/modules/ui/layout/hooks/useShowAuthModal.ts | useShowAuthModal |

### Recoil States

| 文件 | 路徑 | State 名稱 |
|------|------|-----------|
| isCurrentUserLoadedState.ts | packages/twenty-front/src/modules/auth/states/isCurrentUserLoadedState.ts | isCurrentUserLoadedState |
| tokenPairState.ts | packages/twenty-front/src/modules/auth/states/tokenPairState.ts | tokenPairState |
| currentUserState.ts | packages/twenty-front/src/modules/auth/states/currentUserState.ts | currentUserState |
| currentWorkspaceState.ts | packages/twenty-front/src/modules/auth/states/currentWorkspaceState.ts | currentWorkspaceState |

### 後端核心

| 文件 | 路徑 | 關鍵類/方法 |
|------|------|-----------|
| main.ts | packages/twenty-server/src/main.ts | bootstrap |
| app.module.ts | packages/twenty-server/src/app.module.ts | AppModule |
| auth.module.ts | packages/twenty-server/src/engine/core-modules/auth/auth.module.ts | AuthModule |
| auth.resolver.ts | packages/twenty-server/src/engine/core-modules/auth/auth.resolver.ts | AuthResolver, getAuthTokensFromLoginToken |
| workspace.service.ts | packages/twenty-server/src/engine/core-modules/workspace/services/workspace.service.ts | WorkspaceService |

### 配置與啟動

| 文件 | 路徑 | 用途 |
|------|------|------|
| twenty-config.sh | /Users/ym/twenty-ym/twenty-config.sh | 環境變數配置 |
| start_all_service_start.sh | /Users/ym/twenty-ym/start_all_service_start.sh | 啟動腳本 |
| vite.config.ts | packages/twenty-front/vite.config.ts | 前端構建配置 |

---

**報告結束**

