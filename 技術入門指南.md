# Twenty CRM 技術入門指南

## 前言

本文件旨在幫助熟悉 C#/.NET/MSSQL 技術棧的開發人員，快速理解 Twenty CRM 專案的架構、技術選型和開發流程。我們將盡量使用 .NET 的概念進行類比，以加速學習過程。

---

## 1. 專案結構與設定檔解析

本專案採用 **Nx Monorepo** 架構。

### 1.1 什麼是 Nx Monorepo？

**Nx** 是一個用於管理「Monorepo」的工具集。Monorepo 是一種將多個相關但獨立的專案（例如前端、後端、共用函式庫）放在同一個版本控制庫（Git Repo）中的策略。

**與 .NET 解決方案 (.sln) 的類比：**
您可以將整個 `twenty-ym` 目錄想像成一個 Visual Studio 的 `.sln` 解決方案，而 `packages` 資料夾下的每一個子資料夾（如 `twenty-front`, `twenty-server`）則對應一個 `.csproj` 專案。

**核心優勢：**
*   **程式碼共用**：可以輕鬆地建立共用函式庫（如本專案的 `twenty-shared`），並在前端和後端之間共用，無需發布到 NuGet 或 npm。
*   **原子化提交**：一個功能如果同時涉及前端和後端的修改，可以在一個 Git Commit 中完成，保證了版本的一致性。
*   **統一的工具鏈**：所有專案共用一套建置、測試、格式化工具，由 Nx 統一管理。
*   **依賴關係圖**：Nx 能夠分析專案間的依賴關係，只重新建置和測試受變更影響的專案，大幅提升 CI/CD 效率。

### 1.2 重要文檔與資料夾結構

*   **根目錄重要檔案 (`D:\project\twenty-ym`)**
    *   `README.md`: 專案的基本介紹和快速開始指南。
    *   `package.json`: **(類似 .NET 的 `Directory.Build.props`)** 定義了整個工作區 (Workspace) 共用的開發依賴套件（如 TypeScript, Prettier, Nx 本身）和全域指令。
    *   `nx.json`: **(Nx 的大腦)** Nx 的核心設定檔。定義了專案的預設任務（如 `build`, `lint`）和快取策略。
    *   `tsconfig.base.json`: 整個 Monorepo 的基礎 TypeScript 設定，定義了路徑別名（`@`），讓專案間可以方便地互相引用。
    *   `docker-compose.local-test.yml`: 我們用來啟動本地 Docker 環境的設定檔。

*   **資料夾結構**
    *   `packages/`: **(核心程式碼)** 包含了所有的應用程式和函式庫，是開發的主要區域。
        *   `twenty-front`: 前端 React 應用程式。
        *   `twenty-server`: 後端 NestJS 應用程式。
        *   `twenty-shared`: 前後端共用的 TypeScript 程式碼（例如資料結構 DTOs, Enums）。
        *   `twenty-ui`: 可重複使用的 React UI 元件庫。
        *   `...` 其他支援性專案。
    *   `deployment/`: 包含了部署相關的腳本和設定檔，例如我們使用的 `docker-compose.local-test.yml`。
    *   `tools/`: 包含了一些自訂的開發工具，例如 ESLint 規則。

### 1.3 `package.json` vs `project.json`

這是理解 Nx 專案的關鍵。

*   **`package.json` (套件管理器設定)**
    *   **根目錄的 `package.json`**：管理**整個工作區**的開發工具和全域指令。
    *   **`packages/*/package.json`**：**(類似 .csproj 中的 `<PackageReference>`)** 只管理**該專案自身**的執行依賴套件。例如，`twenty-server/package.json` 中定義了 NestJS 相關的套件。

*   **`project.json` (Nx 任務執行器設定)**
    *   **(類似 .csproj 中的 `<Target>`)** 這是 **Nx 專屬**的設定檔，它告訴 Nx 如何對這個專案執行各種「任務」(Targets)。
    *   例如，`twenty-server/project.json` 中的 `targets` 區塊定義了 `build`, `start`, `lint`, `test` 等任務。當您執行 `npx nx build twenty-server` 時，Nx 會查找這個檔案，並執行 `targets.build.options.commands` 中定義的指令。

---

## 2. 整體架構與模組交互

本專案是典型的**前後端分離**架構。

*   **前端 (`twenty-front`)**: 一個單頁應用程式 (SPA)，使用 **React** 和 **TypeScript** 開發。
*   **後端 (`twenty-server`)**: 一個 API 伺服器，使用 **NestJS** 框架（基於 **Node.js** 和 **TypeScript**）開發。
*   **共用層 (`twenty-shared`, `twenty-ui`)**: 提供了共用的型別、介面、商業邏輯和 UI 元件。

**交互流程：**
1.  瀏覽器載入 `twenty-front` 的靜態檔案 (HTML, JS, CSS)。
2.  前端 React 應用程式在瀏覽器中運行，並透過 HTTP 請求與後端 API 進行通訊。
3.  `twenty-server` 接收請求，執行商業邏輯，與資料庫 (PostgreSQL) 和快取 (Redis) 交互，然後回傳結果。

**依賴關係定義：**
*   **`tsconfig.base.json`**: 其中的 `paths` 設定定義了專案間的引用路徑，例如讓 `twenty-server` 可以用 `import ... from 'twenty-shared/...'` 的方式直接引用共用程式碼。
*   **`nx.json`**: `targetDefaults` 和 `dependsOn` 設定定義了任務間的依賴。例如，`build` 一個專案前，必須先 `build` 它所依賴的專案。您可以執行 `npx nx graph` 來視覺化地查看整個專案的依賴關係圖。

---

## 3. 技術棧、建置與生命週期

### 3.1 後端 (twenty-server)

*   **語言**: **TypeScript**
*   **框架**: **NestJS**
    *   **與 ASP.NET Core 的類比**: NestJS 在許多設計理念上深受 ASP.NET Core 啟發。它擁有模組 (Modules)、控制器 (Controllers)、服務 (Services) 和依賴注入 (Dependency Injection) 等核心概念，C# 開發人員會感到非常熟悉。
*   **套件管理**: `package.json` (類似 `.csproj`)，使用 `yarn install` (類似 `dotnet restore`) 來安裝依賴。
*   **程式進入點**: `packages/twenty-server/src/main.ts` (類似 `Program.cs`)。
    *   它使用 `NestFactory.create(AppModule)` 來建立應用實例。
    *   設定全域 Middleware、CORS、Session、Body Parser 等，這與在 `Program.cs` 中設定 Kestrel 和 ASP.NET Core 的 Pipeline 非常相似 (`app.Use...`)。
*   **建置**: `project.json` 中定義了 `build` 任務，執行 `nest build`。這會將 TypeScript 編譯成 JavaScript，並輸出到 `dist` 資料夾，類似 `dotnet build` 將 C# 編譯成 DLL。

### 3.2 前端 (twenty-front)

*   **語言**: **TypeScript** (搭配 **TSX** 語法，類似 Razor Pages 中的 C# + HTML)
*   **框架**: **React**
*   **建置**: 同樣由 `project.json` 定義，使用 **Vite** 作為建置工具，將 TSX 和其他資源打包成靜態 HTML/JS/CSS 檔案。

---

## 4. API 風格：混合模式 (GraphQL + REST)

本專案的 API 風格並非單純的 RESTful，而是以 **GraphQL** 為主，**RESTful API** 為輔的混合模式。

*   **GraphQL (主要)**
    *   **與 RESTful 的區別**: 
        *   **單一端點**: GraphQL 通常只有一個端點（例如 `/graphql`），所有的查詢、修改都發送到這裡。而 RESTful 有許多不同的 URL 端點（`/users`, `/products/{id}`）。
        *   **客戶端決定資料**: 客戶端（前端）可以精確地指定它需要哪些欄位，伺服器只會回傳這些欄位，不多也不少。這避免了 RESTful 中常見的「過度獲取 (Over-fetching)」或「獲取不足 (Under-fetching)」的問題。
        *   **強型別結構**: GraphQL 有一個嚴格的結構定義 (Schema)，定義了所有可用的查詢、型別和欄位。
    *   **格式範例**: 前端發送一個 POST 請求到 `/graphql`，Body 內容如下：
    ```json
    {
      "query": "query FindUser($id: ID!) { user(id: $id) { id name email } }",
      "variables": {
        "id": "123"
      }
    }
    ```
    這段查詢表示「尋找 ID 為 123 的使用者，並且只回傳他的 `id`, `name`, `email` 三個欄位」。

*   **RESTful API (輔助)**
    *   專案中也保留了部分 RESTful 端點（在 `RestApiModule` 中定義），可能用於檔案上傳、Webhooks 或一些不適合 GraphQL 的特定操作。

---

## 5. Docker 映像與容器更新流程

當您修改了程式碼後，需要重新建置映像並更新運行的容器來進行測試。

1.  **重新建置映像**
    在專案根目錄執行此指令。它會使用新的程式碼建立一個帶有 `:latest` 標籤的新映像。
    ```bash
    docker build -f packages/twenty-docker/twenty/Dockerfile -t twenty-zh-tw:latest .
    ```

2.  **更新運行的服務**
    進入 `deployment` 目錄，再次執行 `up` 指令。Docker Compose 會自動比較新舊映像，並只重新啟動那些基於已更新映像的容器。
    ```bash
    cd deployment
    docker compose -f docker-compose.local-test.yml up -d
    ```

---

## 6. 資料庫 (PostgreSQL) 設定

### 6.1 設定方式

所有與本地測試環境相關的資料庫設定都在 `deployment/docker-compose.local-test.yml` 的 `db-test` 服務中定義。

*   **映像**: `postgres:16`
*   **帳號**: `postgres`
*   **密碼**: `test_password_local`
*   **資料庫名稱**: `default`

### 6.2 表、索引與欄位如何建立？

本專案使用 **TypeORM** 作為 ORM (Object-Relational Mapper)，類似於 .NET 中的 **Entity Framework**。

*   **實體 (Entity)**: 開發人員在程式碼中定義 TypeScript 類別並用裝飾器 (Decorator) 標記，這些類別對應資料庫中的表。
*   **遷移 (Migration)**: 當實體變更後，開發人員會產生一個「遷移檔」（在 `packages/twenty-server/src/database/typeorm/core/migrations` 中）。這個檔案記錄了如何用 SQL 指令（如 `CREATE TABLE`, `ADD COLUMN`）來更新資料庫結構。
*   **執行**: 當 `server-test` 容器啟動時，它會自動執行所有尚未執行的遷移檔，從而建立或更新資料庫的結構。這個流程由 `packages/twenty-server/package.json` 中的 `database:migrate:prod` 指令觸發。

### 6.3 GUI 工具推薦

若要像使用 SSMS 一樣用圖形化介面操作 PostgreSQL，可以選擇以下任一工具：

*   **pgAdmin**: PostgreSQL 官方且功能最強大的管理工具。([下載](https://www.pgadmin.org/download/))
*   **DBeaver**: 一款開源的、支援多種資料庫的通用客戶端。([下載](https://dbeaver.io/download/))

**如何連線？**
預設情況下，`docker-compose.local-test.yml` 並未將資料庫的 5432 埠對外暴露。您需要手動修改該檔案，將 `db-test` 服務下的 `ports` 區塊取消註解：
```yaml
# ...
  db-test:
    # ...
    ports:
      # 取消下面這行的註解，即可從本機連線
      - "127.0.0.1:15432:5432"
# ...
```
修改後，重新執行 `docker-compose up -d`，然後您就可以使用以下資訊從 GUI 工具連線：
*   **主機**: `localhost`
*   **埠**: `15432`
*   **使用者名稱**: `postgres`
*   **密碼**: `test_password_local`

---

## 7. Redis 的作用與設定

### 7.1 設定方式

Redis 服務同樣在 `docker-compose.local-test.yml` 的 `redis-test` 服務中定義。後端 `server-test` 透過 `REDIS_URL: redis://redis-test:6379` 這個環境變數來與之連線。

### 7.2 Redis 在此專案的作用

根據依賴套件 (`bullmq`, `cache-manager-redis-yet`, `connect-redis`) 分析，Redis 在本專案中扮演了三個核心角色：

1.  **背景工作佇列 (Background Job Queue)**
    *   **工具**: `bullmq`
    *   **用途**: 處理耗時或非同步的任務，例如發送電子郵件、處理 Webhooks 等。`server-test` 將任務放入佇列，而 `worker-test` 服務則從佇列中取出並執行任務。這確保了 API 請求可以快速回應，而不會被長時間運行的任務阻塞。

2.  **應用程式快取 (Application Cache)**
    *   **工具**: `cache-manager-redis-yet`
    *   **用途**: 遵循 NestJS 的 `CacheModule` 模式，將頻繁查詢但不常變動的資料（例如設定、使用者權限等）快取在 Redis 中，以降低資料庫負載。

3.  **Session 儲存 (Session Storage)**
    *   **工具**: `connect-redis`
    *   **用途**: 儲存使用者的登入狀態 (Session)。將 Session 存放在 Redis 中，可以讓後端服務變成「無狀態 (Stateless)」，未來如果需要水平擴展（同時運行多個 `server-test` 實例），使用者也不會因為請求被分配到不同實例而掉線。

### 7.3 如何檢視 Redis？

您可以透過 `redis-test` 容器暴露的 `16379` 埠來檢視 Redis 中的資料。
1.  **CLI 方式**: 
    ```bash
    # 進入 redis-test 容器
    docker exec -it twenty-redis-test sh

    # 啟動 redis-cli
    redis-cli

    # 執行 Redis 指令，例如查看所有 key
    keys *
    ```
2.  **GUI 方式**: 
    *   可以使用 **Another Redis Desktop Manager** ([下載](https://github.com/qishibo/AnotherRedisDesktopManager/releases)) 等 GUI 工具。
    *   連線資訊：主機 `localhost`，埠 `16379`。
