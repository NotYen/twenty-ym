# 2026-01-12 修改記錄

> 本次修改解決了三個問題：Relation tag 跳轉空白、數據模型編輯錯誤、Slide Panel 欄位順序

---

## 修改 1：修復 Relation Tag 點擊跳轉空白問題

### 問題描述

**現象**：
- AWS 環境中，Side Panel 的 relation chip 點擊跳轉後頁面空白
- 「有時可以有時不行」- 首次訪問人員/公司時點擊會空白，訪問其他頁面後再回來就正常
- API 請求成功，返回正確資料
- 下拉選單可以正常顯示 relation 資料

**問題行為模式**：
| 操作 | 結果 |
|------|------|
| 人員 → 點擊公司 relation tag | ✅ 正常 |
| 公司 → 點擊機會/報價單 relation tag | ❌ 空白 |
| 機會 → 點擊任何 relation tag | ✅ 正常 |
| 訪問其他頁面後 → 再回人員/公司 | ✅ 又正常了 |

**Console 錯誤**：
```
An error occurred! ... OpportunityConnection ...
either ensure all objects have an ID or a custom merge function
```

### 核心原因分析

**Twenty 的架構設計**：
- 前端：React + Recoil + Apollo Client (GraphQL)
- 使用 cache-first 策略提升效能

**用戶的效能優化**：
- 將初始載入從 60 筆改為 30 筆
- 使用 `cache-first` fetchPolicy
- INP 從 500-600ms 降到 300-400ms

**問題根源**：
當使用 `cache-first` 策略時：
1. 首次訪問「公司」頁面 → cache 中可能只有部分資料（如 `totalCount`）
2. 點擊「機會」relation tag → 觸發 GraphQL 查詢
3. API 返回完整的 `OpportunityConnection` 資料（包括 `edges`, `pageInfo`, `totalCount`）
4. **Apollo 不知道如何 merge 這兩個不同結構的資料** → 頁面空白
5. 訪問其他頁面後，cache 被更新 → 再回來就正常了

### 解決方案

**修改檔案**：
- `packages/twenty-front/src/modules/apollo/hooks/useApolloFactory.ts`

**修改內容**：
在 `InMemoryCache` 的 `typePolicies` 中，為所有 Connection 類型添加 custom merge function：

```typescript
cache: new InMemoryCache({
  typePolicies: {
    RemoteTable: {
      keyFields: ['name'],
    },
    Query: {
      fields: {
        // 通用的 Connection 類型 merge 策略
        // 解決 cache-first 策略下，首次訪問時 cache 中只有部分資料（如 totalCount）
        // 再次查詢返回完整資料（包括 edges）時，Apollo 不知道如何 merge 的問題
        opportunities: {
          keyArgs: false,
          merge(existing, incoming) {
            return incoming;
          },
        },
        salesQuotes: {
          keyArgs: false,
          merge(existing, incoming) {
            return incoming;
          },
        },
        people: {
          keyArgs: false,
          merge(existing, incoming) {
            return incoming;
          },
        },
        companies: {
          keyArgs: false,
          merge(existing, incoming) {
            return incoming;
          },
        },
        tasks: {
          keyArgs: false,
          merge(existing, incoming) {
            return incoming;
          },
        },
        notes: {
          keyArgs: false,
          merge(existing, incoming) {
            return incoming;
          },
        },
        salesQuoteLineItems: {
          keyArgs: false,
          merge(existing, incoming) {
            return incoming;
          },
        },
      },
    },
  },
}),
```

**修改說明**：
- `keyArgs: false`：不使用任何參數作為 cache key，所有查詢共用同一個 cache entry
- `merge(existing, incoming) { return incoming; }`：當有新資料時，直接使用新資料覆蓋舊資料，不嘗試 merge

**效果**：
- ✅ 解決 relation tag 跳轉空白問題
- ✅ 保留所有效能優化（cache-first、30 筆初始載入）
- ✅ 消除「有時可以有時不行」的不穩定行為
- ✅ Console 不再出現錯誤訊息

---

## 修改 2：修復 Missing Import 錯誤

### 問題描述

**現象**：
- AWS 環境中訪問「設定 > 數據模型 > 編輯欄位」頁面時報錯
- 錯誤訊息：
```
ReferenceError: getFieldMetadataItemInitialValues is not defined
at Ve (SettingsObjectFieldEdit-CVXTwwS-.js:1:1761)
```

### 核心原因

**Cherry-pick 不完整**：
根據 `CHERRY_PICK_RECORD.md`：
```
| Currency Save 按鈕 | #16864 | 修復 Currency 欄位設定頁面 Save 按鈕無法正確追蹤 dirty state
（新增 getFieldMetadataItemInitialValues.ts，保留本地 readonly 修改） | 2026-01-11 |
```

Cherry-pick 時：
- ✅ 新增了 `getFieldMetadataItemInitialValues.ts` 檔案
- ✅ 在 `SettingsObjectFieldEdit.tsx` 中使用了這個函數
- ❌ **忘記加入 import 語句**

**為什麼本地可能正常**：
1. TypeScript 編譯器 cache
2. 開發模式的 hot reload
3. 但 AWS 生產環境的 build 更嚴格，會檢查所有依賴

### 解決方案

**修改檔案**：
- `packages/twenty-front/src/pages/settings/data-model/SettingsObjectFieldEdit.tsx`

**修改內容**：
在 import 區塊加入缺少的 import：

```typescript
import { useNavigateApp } from '~/hooks/useNavigateApp';
import { useNavigateSettings } from '~/hooks/useNavigateSettings';
import { getFieldMetadataItemInitialValues } from '~/pages/settings/data-model/utils/getFieldMetadataItemInitialValues';

//TODO: fix this type
export type SettingsDataModelFieldEditFormValues = z.infer<
  ReturnType<typeof settingsFieldFormSchema>
> &
  any;
```

**效果**：
- ✅ 修復數據模型欄位編輯頁面錯誤
- ✅ Currency 欄位設定頁面 Save 按鈕可以正確追蹤 dirty state

---

## 修改 3：Slide Panel 欄位順序跟隨 Table View

### 問題描述

**現象**：
- Slide Panel 的欄位順序是按字母排序
- Table View 的欄位順序是按用戶拖拽調整的 `viewField.position`
- 兩者不一致，造成使用體驗不佳

**用戶需求**：
- 在 Table View 拖拽調整欄位順序後，Slide Panel 的欄位順序也要跟著改變

### 核心原因

**目前的實作**：
- Slide Panel 使用 `useFieldListFieldMetadataItems` hook
- 原本的排序邏輯：
```typescript
.sort((fieldMetadataItemA, fieldMetadataItemB) =>
  fieldMetadataItemA.name.localeCompare(fieldMetadataItemB.name),
)
```
- 按照欄位名稱字母順序排序，沒有讀取 view 的 `viewField.position`

### 解決方案

**修改檔案**：
- `packages/twenty-front/src/modules/object-record/record-field-list/hooks/useFieldListFieldMetadataItems.ts`

**修改內容**：

1. **新增 import**：
```typescript
import { useGetCurrentViewOnly } from '@/views/hooks/useGetCurrentViewOnly';
```

2. **獲取當前 view**：
```typescript
const { currentView } = useGetCurrentViewOnly();
```

3. **修改排序邏輯**：
```typescript
.sort((fieldMetadataItemA, fieldMetadataItemB) => {
  // 從當前 view 獲取 viewField 的 position
  const viewFieldA = currentView?.viewFields?.find(
    (vf) => vf.fieldMetadataId === fieldMetadataItemA.id,
  );
  const viewFieldB = currentView?.viewFields?.find(
    (vf) => vf.fieldMetadataId === fieldMetadataItemB.id,
  );

  // 如果兩個欄位都有 position，按 position 排序
  if (isDefined(viewFieldA?.position) && isDefined(viewFieldB?.position)) {
    return viewFieldA.position - viewFieldB.position;
  }

  // 如果只有 A 有 position，A 排前面
  if (isDefined(viewFieldA?.position)) {
    return -1;
  }

  // 如果只有 B 有 position，B 排前面
  if (isDefined(viewFieldB?.position)) {
    return 1;
  }

  // 如果都沒有 position，按字母順序排序
  return fieldMetadataItemA.name.localeCompare(fieldMetadataItemB.name);
});
```

**效果**：
- ✅ Slide Panel 欄位順序與 Table View 一致
- ✅ 用戶在 Table View 拖拽調整欄位順序時，Slide Panel 自動同步
- ✅ 不影響頁面切換效能（viewFields 已在 cache 中）
- ✅ 保留原有的過濾和分組邏輯
- ✅ 對於沒有在 view 中的欄位，會放在最後並按字母順序排列

---

## 修改檔案清單

| 檔案 | 修改類型 | 說明 |
|------|---------|------|
| `packages/twenty-front/src/modules/apollo/hooks/useApolloFactory.ts` | 修改 | 新增 Connection 類型 merge function |
| `packages/twenty-front/src/pages/settings/data-model/SettingsObjectFieldEdit.tsx` | 修改 | 新增缺少的 import |
| `packages/twenty-front/src/modules/object-record/record-field-list/hooks/useFieldListFieldMetadataItems.ts` | 修改 | 修改欄位排序邏輯 |

---

## 測試步驟

### 1. 本地測試

```bash
# 清除 build cache
rm -rf packages/twenty-front/dist
rm -rf packages/twenty-front/.nx

# Build
cd packages/twenty-front
yarn build

# 啟動本地 Docker
cd ../../docker
./run-local.sh
```

### 2. 功能驗證清單

#### Relation Tag 跳轉測試
- [ ] 清除瀏覽器 cache（使用無痕模式）
- [ ] 訪問「公司」頁面
- [ ] 點擊「機會」relation tag → 確認頁面正常顯示
- [ ] 點擊「報價單」relation tag → 確認頁面正常顯示
- [ ] 訪問「人員」頁面
- [ ] 點擊「公司」relation tag → 確認頁面正常顯示
- [ ] 訪問「機會」頁面
- [ ] 點擊任何 relation tag → 確認頁面正常顯示
- [ ] 確認 Console 無錯誤訊息

#### 數據模型編輯測試
- [ ] 訪問「設定 > 數據模型」
- [ ] 選擇任一 object（如「公司」）
- [ ] 點擊任一欄位進入編輯頁面
- [ ] 確認頁面正常載入，沒有錯誤
- [ ] 修改欄位設定並保存
- [ ] 確認 Save 按鈕正常運作

#### Slide Panel 欄位順序測試
- [ ] 訪問任一 object 的列表頁面（如「公司」）
- [ ] 在 Table View 拖拽調整欄位順序（如將「電話」移到最前面）
- [ ] 點擊任一 record 打開 Slide Panel
- [ ] 確認 Slide Panel 的欄位順序與 Table View 一致
- [ ] 關閉 Slide Panel，再次調整 Table View 欄位順序
- [ ] 再次打開 Slide Panel，確認順序已同步

#### 效能驗證
- [ ] 頁面切換速度維持在 300-400ms（不受影響）
- [ ] 下拉選單仍然正常顯示 relation 資料
- [ ] 沒有明顯的效能下降

---

## 部署到 AWS

**確認本地測試通過後**，執行以下步驟：

### 1. Build AMD64 Images

```bash
./docker/dev-flow/aws/build-amd64-images.sh \
  --backend-version b_20260112_v3_aws_image \
  --frontend-version f_20260112_v3_aws_image
```

### 2. 部署到 AWS

```bash
./docker/dev-flow/aws/deploy-to-aws.sh \
  --backend-tag b_20260112_v3_aws_image \
  --frontend-tag f_20260112_v3_aws_image
```

### 3. AWS 環境驗證

SSH 到 AWS 後執行相同的功能驗證清單。

---

## 預防措施

### Cherry-pick 檢查清單

當 cherry-pick 包含新檔案的 commit 時：

- [ ] 確認新檔案已加入
- [ ] 確認所有使用該檔案的地方都有 import
- [ ] 執行 `yarn build` 確認沒有編譯錯誤
- [ ] 執行 `yarn lint` 確認沒有 lint 錯誤
- [ ] 清除 cache 後重新測試

### Build 前檢查

```bash
# 清除所有 cache
rm -rf packages/twenty-front/dist
rm -rf packages/twenty-front/.nx
rm -rf node_modules/.cache

# 重新 build（確保是乾淨的 build）
yarn build
```

### TypeScript 類型檢查

```bash
# 執行 TypeScript 類型檢查
cd packages/twenty-front
yarn tsc --noEmit
```

---

## 相關文件

- `docs/web_performance_ptimization(WPO)/PERFORMANCE_OPTIMIZATION_COMPLETE.md` - 效能優化完整文件
- `docs/web_performance_ptimization(WPO)/core_cause_analysis_report.md` - 核心問題分析
- `docs/CHERRY_PICK_RECORD.md` - Cherry-pick 記錄
- [Apollo Client - Customizing cache IDs](https://www.apollographql.com/docs/react/caching/cache-configuration/#customizing-cache-ids)
- [Apollo Client - Customizing the behavior of cached fields](https://www.apollographql.com/docs/react/caching/cache-field-behavior/)

---

## 總結

本次修改解決了三個問題：

1. ✅ **Relation tag 跳轉空白** - Apollo Cache 的 Connection 類型 merge 衝突
2. ✅ **數據模型編輯錯誤** - Cherry-pick 時缺少 import
3. ✅ **Slide Panel 欄位順序** - 與 Table View 不一致

所有修改都：
- ✅ 遵守 Twenty 的設計架構
- ✅ 不影響其他正常執行的功能
- ✅ 保留本地所有修改
- ✅ 保留頁面切換效能優化（速度）

---

---

# 2026-01-13 修改記錄

> 本次修改解決了兩個問題：Slide Panel 點擊 Relation Tag 空白、Dashboard 顯示異常

---

## 修改 4：修復 Slide Panel 點擊 Relation Tag 空白問題（進階修復）

### 問題描述

**現象**：
- 在 Table View 點擊 Relation Tag 開啟 Slide Panel 後，頁面顯示空白
- 影響所有 object 的 Relation Tag 點擊
- 與 2026-01-12 的修改 1 不同，這是 `isRecordPageEnabled` feature flag 開啟後的新問題

**Console 日誌**：
```
[useRecordPageLayoutId] Object
[PageLayoutRecordPageRenderer] render Object
```

### 核心原因分析

**問題根源**：
效能優化將全域 Apollo `fetchPolicy` 從 `cache-and-network` 改成 `cache-first`，導致當 `isRecordPageEnabled` feature flag 開啟時：

1. Slide Panel 走 `PageLayoutRecordPageRenderer` 路徑
2. 這個路徑的複雜初始化流程與 `cache-first` 不相容
3. Cache 沒資料時，頁面顯示空白

**程式碼流程**：
```
點擊 Relation Tag
  → PageLayoutDispatcher
    → shouldUsePageLayout = true (因為 isRecordPageEnabled)
      → PageLayoutRecordPageRenderer
        → 複雜的初始化流程
          → cache-first 沒資料
            → 空白頁面
```

### 解決方案

**修改檔案**：
- `packages/twenty-front/src/modules/object-record/record-show/components/PageLayoutDispatcher.tsx`

**修改內容**：
讓 Slide Panel (right drawer) 繞過 `PageLayoutRecordPageRenderer`，使用原本穩定的 `RecordShowContainer`：

```typescript
// 在 right drawer (slide panel) 中時，使用原本穩定的 RecordShowContainer
// 避免 PageLayout 初始化時序問題導致空白
const shouldUsePageLayout =
  !isInRightDrawer &&
  (targetRecordIdentifier.targetObjectNameSingular ===
    CoreObjectNameSingular.Dashboard ||
    isRecordPageEnabled);
```

**修改說明**：
- 加入 `!isInRightDrawer` 條件
- Slide Panel 使用 `RecordShowContainer`（穩定路徑）
- 主頁面繼續使用 `PageLayoutRecordPageRenderer`（支援 Dashboard 等進階功能）

**效果**：
- ✅ Slide Panel 點擊 Relation Tag 正常顯示
- ✅ 保留效能優化（cache-first）
- ✅ 主頁面功能不受影響

---

## 修改 5：修復 Dashboard 顯示異常問題

### 問題描述

**現象**：
- Dashboard 頁面先顯示一般 record 的 layout（時間軸、任務、備註、附檔）
- 然後這些內容消失，Dashboard 變成空白或顯示正確內容
- 造成視覺閃爍，使用體驗不佳

### 核心原因分析

**問題根源**：
修復修改 4 時，修改了 `useRecordPageLayoutId.ts`，讓 loading 時返回預設 layout ID。但：

1. Dashboard 沒有預設 layout
2. Dashboard 的 `pageLayoutId` 存在資料庫 record 中
3. 在 record 載入前，返回預設 layout ID
4. 導致 Dashboard 先顯示錯誤的一般 record layout

**程式碼流程**：
```
訪問 Dashboard
  → useRecordPageLayoutId
    → loading = true
      → 返回預設 layout ID (錯誤！)
        → 顯示一般 record layout
  → record 載入完成
    → 返回正確的 pageLayoutId
      → 顯示 Dashboard widgets
```

### 解決方案

**修改檔案**：
- `packages/twenty-front/src/modules/page-layout/hooks/useRecordPageLayoutId.ts`

**修改內容**：
新增 `OBJECTS_REQUIRING_RECORD_PAGE_LAYOUT_ID` 列表，讓 Dashboard 等 object 等 record 載入後才取得 `pageLayoutId`：

```typescript
import { CoreObjectNameSingular } from '@/object-metadata/types/CoreObjectNameSingular';

// Dashboard 需要從 record 取得 pageLayoutId，沒有預設 layout
const OBJECTS_REQUIRING_RECORD_PAGE_LAYOUT_ID = [
  CoreObjectNameSingular.Dashboard,
];

export const useRecordPageLayoutId = ({
  objectNameSingular,
  recordId,
}: {
  objectNameSingular: string;
  recordId: string;
}) => {
  // ... 其他程式碼 ...

  // 檢查是否需要從 record 取得 pageLayoutId
  const requiresRecordPageLayoutId =
    OBJECTS_REQUIRING_RECORD_PAGE_LAYOUT_ID.includes(
      objectNameSingular as CoreObjectNameSingular,
    );

  // Dashboard 等 object 必須等 record 載入後才能取得 pageLayoutId
  // 在 loading 時返回 null，避免先顯示錯誤的 layout
  if (requiresRecordPageLayoutId) {
    return {
      pageLayoutId: loading ? null : record?.pageLayoutId ?? null,
      loading,
    };
  }

  // 一般 object 使用預設 layout
  return {
    pageLayoutId: loading
      ? DEFAULT_RECORD_PAGE_LAYOUT_ID
      : record?.pageLayoutId ?? DEFAULT_RECORD_PAGE_LAYOUT_ID,
    loading,
  };
};
```

**修改說明**：
- 新增 `OBJECTS_REQUIRING_RECORD_PAGE_LAYOUT_ID` 列表
- Dashboard 在 loading 時返回 `null`，不顯示任何 layout
- 一般 object 保持原有行為（使用預設 layout）

**效果**：
- ✅ Dashboard 不再先顯示錯誤的 layout
- ✅ Dashboard 正確顯示圖表 widgets
- ✅ 一般 record 頁面不受影響

---

## 2026-01-13 修改檔案清單

| 檔案 | 修改類型 | 說明 |
|------|---------|------|
| `packages/twenty-front/src/modules/object-record/record-show/components/PageLayoutDispatcher.tsx` | 修改 | 加入 `!isInRightDrawer` 條件 |
| `packages/twenty-front/src/modules/page-layout/hooks/useRecordPageLayoutId.ts` | 修改 | 新增 Dashboard 特殊處理邏輯 |

---

## 2026-01-13 測試步驟

### 功能驗證清單

#### Slide Panel Relation Tag 測試
- [ ] 訪問「公司」列表頁面
- [ ] 點擊任一公司的「機會」Relation Tag
- [ ] 確認 Slide Panel 正常顯示機會內容
- [ ] 點擊「報價單」Relation Tag
- [ ] 確認 Slide Panel 正常顯示報價單內容
- [ ] 訪問「人員」列表頁面
- [ ] 點擊任一人員的「公司」Relation Tag
- [ ] 確認 Slide Panel 正常顯示公司內容

#### Dashboard 測試
- [ ] 訪問 Dashboard 頁面
- [ ] 確認不會先顯示一般 record layout
- [ ] 確認 Dashboard 正確顯示圖表 widgets
- [ ] 切換不同 Dashboard
- [ ] 確認每個 Dashboard 都正常顯示

#### 一般 Record 頁面測試
- [ ] 訪問「公司」詳情頁面
- [ ] 確認正常顯示（時間軸、任務、備註、附檔）
- [ ] 訪問「人員」詳情頁面
- [ ] 確認正常顯示
- [ ] 訪問「機會」詳情頁面
- [ ] 確認正常顯示

#### 效能驗證
- [ ] 頁面切換速度維持優化效果
- [ ] Slide Panel 開啟速度正常
- [ ] 沒有明顯的效能下降

---

## 效能優化保留確認

以下效能優化成果**保留不變**：

| 項目 | 狀態 | 說明 |
|------|------|------|
| 全域 `cache-first` | ✅ 保留 | 在 `useApolloFactory.ts`，沒有被修改 |
| Connection 類型 merge function | ✅ 保留 | 在 `useApolloFactory.ts` |
| Table View 欄位順序同步 | ✅ 保留 | 在 `useFieldListFieldMetadataItems.ts` |
| 初始載入 30 筆 | ✅ 保留 | 沒有被修改 |

---

## 相關文件

- `docs/troubleshooting/20260113_SLIDE_PANEL_AND_DASHBOARD_FIX.md` - 詳細修復說明
- `docs/web_performance_ptimization(WPO)/TABLE_SWITCH_OPTIMIZATION_2026_01_12.md`
- `docs/web_performance_ptimization(WPO)/SIDE_PANEL_TAG_NAVIGATION_ANALYSIS.md`

---

## 版本歷史

| 日期 | 版本 | 說明 |
|-----|------|------|
| 2026-01-12 | v1.0 | 初始版本 - 三個修改完成 |
| 2026-01-13 | v1.1 | 新增修改 4、5 - Slide Panel 空白修復、Dashboard 修復 |

